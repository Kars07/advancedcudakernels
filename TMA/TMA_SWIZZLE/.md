By default, the TMA engine loads data to shared memory in the same order as it is laid out in global
memory. However, this layout may not be optimal for certain shared memory access patterns, as it
could cause shared memory bank conflicts. To improve performance and reduce bank conflicts, we
can change the shared memory layout by applying a ‘swizzle pattern’.
Shared memory has 32 banks that are organized such that successive 32-bit words map to successive
banks. Each bank has a bandwidth of 32 bits per clock cycle. When loading and storing shared memory,
bank conflicts arise if the same bank is used multiple times within a transaction, resulting in reduced
bandwidth.
To ensure that data is laid out in shared memory in such a way that user code can avoid shared memory
bank conflicts, the TMA engine can be instructed to ‘swizzle’ the data before storing it in shared
memory and ‘unswizzle’ it when copying the data back from shared memory to global memory. The
tensor map encodes the ‘swizzle mode’ indicating which swizzle pattern is used.


Considerations. When applying a TMA swizzle pattern, it is crucial to adhere to specific memory requirements:
▶ Global memory alignment: Global memory must be aligned to 128 bytes.
▶ Shared memory alignment: For simplicity shared memory should be aligned according to the
number of bytes after which the swizzle pattern repeats. When the shared memory buffer is
not aligned by the number of bytes by which the swizzle pattern repeats itself, there is an offset
between the swizzle pattern and the shared memory. See comment, below.
▶ Inner dimension: The inner dimension of the shared memory block must meet the size requirements
specified in table Table 10. If these requirements are not met, the instruction is considered
invalid. Additionally, if the swizzle width exceeds the inner dimension, ensure that the shared
memory is allocated to accommodate the full swizzle width.
▶ Granularity: The granularity of swizzle mapping is fixed at 16 bytes. This means that data is
organized and accessed in chunks of 16 bytes, which must be considered when planning memory
layout and access patterns.

Swizzle Pattern Pointer Offset Computation. Here, we describe how to determine the offset between
the swizzle pattern and the shared memory, when the shared memory buffer is not aligned by the
number of bytes by which the swizzle pattern repeats itself. When using TMA, the shared memory is
required to be aligned to 128 bytes. To find how many times the shared memory buffer relative to the
swizzle pattern is shifted by that, apply the corresponding offset formula.

Swizzle Mode Offset Formula Index Relation
CU_TENSOR_MAP_SWIZZ(LrEe_i1n2t8eBrpret_cast
<uintptr_t>(smem_ptr)∕128)%8
smem[y][x] <->
smem[y][((y+offset)%8)^x]
CU_TENSOR_MAP_SWIZZ(LrEe_i6n4tBerpret_cast
<uintptr_t>(smem_ptr)∕128)%4
smem[y][x] <->
smem[y][((y+offset)%4)^x]
CU_TENSOR_MAP_SWIZZ(LrEe_i3n2tBerpret_cast
<uintptr_t>(smem_ptr)∕128)%2
smem[y][x] <->
smem[y][((y+offset)%2)^x]

Pattern Swizzle
width
Shared box’s inner
dimension
Repeats
after
Shared memory
alignment
Global memory
alignment
CU_TENSOR_MAP_SWIZZLE1_21828B
bytes
<=128 bytes 1024
bytes
128 bytes 128 bytes
CU_TENSOR_MAP_SWIZZLE6_464B
bytes
<=64 bytes 512
bytes
128 bytes 128 bytes
CU_TENSOR_MAP_SWIZZLE3_232B
bytes
<=32 bytes 256
bytes
128 bytes 128 bytes
CU_TENSOR_MAP_SWIZZLE_NONE
(default)
128 bytes 16 bytes
