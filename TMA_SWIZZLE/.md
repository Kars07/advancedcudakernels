By default, the TMA engine loads data to shared memory in the same order as it is laid out in global
memory. However, this layout may not be optimal for certain shared memory access patterns, as it
could cause shared memory bank conflicts. To improve performance and reduce bank conflicts, we
can change the shared memory layout by applying a ‘swizzle pattern’.
Shared memory has 32 banks that are organized such that successive 32-bit words map to successive
banks. Each bank has a bandwidth of 32 bits per clock cycle. When loading and storing shared memory,
bank conflicts arise if the same bank is used multiple times within a transaction, resulting in reduced
bandwidth.
To ensure that data is laid out in shared memory in such a way that user code can avoid shared memory
bank conflicts, the TMA engine can be instructed to ‘swizzle’ the data before storing it in shared
memory and ‘unswizzle’ it when copying the data back from shared memory to global memory. The
tensor map encodes the ‘swizzle mode’ indicating which swizzle pattern is used.


Considerations. When applying a TMA swizzle pattern, it is crucial to adhere to specific memory requirements:
▶ Global memory alignment: Global memory must be aligned to 128 bytes.
▶ Shared memory alignment: For simplicity shared memory should be aligned according to the
number of bytes after which the swizzle pattern repeats. When the shared memory buffer is
not aligned by the number of bytes by which the swizzle pattern repeats itself, there is an offset
between the swizzle pattern and the shared memory. See comment, below.
▶ Inner dimension: The inner dimension of the shared memory block must meet the size requirements
specified in table Table 10. If these requirements are not met, the instruction is considered
invalid. Additionally, if the swizzle width exceeds the inner dimension, ensure that the shared
memory is allocated to accommodate the full swizzle width.
▶ Granularity: The granularity of swizzle mapping is fixed at 16 bytes. This means that data is
organized and accessed in chunks of 16 bytes, which must be considered when planning memory
layout and access patterns.
